#-*- coding:utf-8 -*-

from androguard.core.bytecodes import apk
from androguard.core.bytecodes.apk import APK
from androguard.session import Session
from androguard.core.bytecodes.dvm import DalvikVMFormat
from androguard.misc import AnalyzeAPK
from androguard.util import get_certificate_name_string
from asn1crypto import x509
from androguard.misc import AnalyzeAPK
from pygeoip.util import ip2long
from selenium import webdriver
import PERMISSIONS_RULE_kor #PERMISSONS
from io import BytesIO
from PIL import Image
from pathlib import Path
import PERMISSIONS_RULE_kor
import hashlib
import re
import functools
import operator
import pygeoip
import requests
import Mal_API_RULE
import json
import time
import base64
import os
import zipfile
import shutil


sample = r'E:\프로젝트\mal_apk_10.06\88feb2d1e34aa009c1f78bda57578f62f2507bc05c186472faa5513a8f093d99.apk'
start = time.time()

scan_url = 'http://36.225.145.56/'

headers = {'API-Key':'d0016479-ae49-4d5c-bb42-b266ebcf5538','Content-Type':'application/json'}
data = {"url": scan_url, "visibility": "public"}
response = requests.post('https://urlscan.io/api/v1/scan/',headers=headers, data=json.dumps(data))

chromedriver = 'chromedriver.exe' #크롬 버전에 맞는 chromedriver.exe 다운 필요

def printRecord(tgt):
    rec = gi.record_by_name(tgt)
    city = rec['city']
    country = rec['country_name']
    long = rec['longitude']
    lat = rec['latitude']

    print('국가: ' + str(country))
    print('도시: ' + str(city))
    print('위도: ' + str(lat))
    print('경도: '+ str(long))

print ('\n1. URL National Information')

if 'https' in scan_url:
    scan_url = scan_url.replace('https://', '')

elif 'http' in scan_url:
    scan_url = scan_url.replace('http://', '')

url_ab = []
url_cd = []
    
if '/' in scan_url:
    index = scan_url.find('/')
    for i in scan_url:
        url_ab.append(i)
try:
    del url_ab[index:]
    scan_url = ''.join(url_ab)
except:
    pass

if ':' in scan_url:
    index = scan_url.find(':')
    for i in scan_url:
        url_cd.append(i)
if len(url_cd) != 0:
    try:
        del url_cd[index:]
        scan_url = ''.join(url_cd)
    except:
        pass

m = re.match('(\d+)[.](\d+)[.](\d+)[.](\d+)', scan_url)

try:
    if m != None:
        gi = pygeoip.GeoIP('./GeoLiteCity.dat')
        print('URL: ' + scan_url)
        printRecord(scan_url)
    else:
        #print("Not Found")
        search_url = 'https://urlscan.io/search/#'+scan_url
    
        driver = webdriver.Chrome(chromedriver)
        driver.get(search_url)
        time.sleep(3)
        url_list = driver.find_elements_by_css_selector(
            "#scans > div > table > tbody > tr")
        
        for item in url_list:
            ahref = item.find_element_by_tag_name("a").get_attribute("href")
            select_url = ahref
            break
    
        driver.quit()

        driver = webdriver.Chrome(chromedriver)
        driver.get(select_url)
        time.sleep(3)
        for label in driver.find_elements_by_css_selector(
            "#summary > div > div.col.col-md-7 > div.panel.panel-default > div > b:nth-child(6)"):
            label_nat = label.text
            break

        driver.quit()

        print('URL: ' + scan_url)
        print('국가: ' + label_nat)
except:
    pass

apkf = APK(sample)
apk_path = sample
apk_name = Path(apk_path).stem

print('\n2. Icon')
#print(apkf.get_app_icon())
try:
    app_icon_file = apkf.get_app_icon()
    app_icon_data = apkf.get_file(app_icon_file)
    size = (256, 256)
    buffered = BytesIO()
    im = Image.open(BytesIO(app_icon_data))
    im = im.resize(size, Image.ANTIALIAS)
    im.save(apk_name + '.png')
    im_name = apk_name + '.png'
    print(im_name + " 저장 성공")
except:
    print("Icon 저장 실패")

print ('\n3. App Name')
print(apkf.get_app_name())

print ('\n4. Package')
print(apkf.get_package())
package = apkf.get_package()

print ('\n5. Permissions')
Perm = apkf.get_permissions()

for i in Perm:
    Perm_list = i.replace("android.permission.","")
    try:
        MAN_PERM = PERMISSIONS_RULE_kor.DVM_PERMISSIONS['MANIFEST_PERMISSION'][Perm_list]
        print(i,' :',MAN_PERM)
    except:
        print(i,' :','unknown')

print ('\n6. Main Activity')
print(apkf.get_main_activity())

print ('\n7. Activities')
print(apkf.get_activities())

print ('\n8. Services')
print(apkf.get_services())

print('\n9. Hash')
#s = Session()
#digest = s.add(sample)

f = open(sample, "rb")
data = f.read()
f.close()

#print("MD5 of the file: " + hashlib.md5(data).hexdigest())
print("sha1 of the file: " + hashlib.sha1(data).hexdigest())
#print("SHA256 of the file: {}".format(digest))


print('\n10. Interesting String')
classes = apkf.get_dex()
a = DalvikVMFormat(classes)
dat = []
dat.append(a.get_strings())

and_a = apk.APK(sample)
rsrc = and_a.get_android_resources() 
pkg = rsrc.get_packages_names()[0]
rsrc.get_strings_resources()
for i in rsrc.values[pkg].keys():
    try:
        for duo in rsrc.values[pkg][i]['string']:
            dat.append('"'+duo[0]+'" : "'+duo[1]+'"')
    except:
        print("Not String")
        pass
dat = str(dat)
st_ip = re.findall('(\d+)[.](\d+)[.](\d+)[.](\d+)', dat)
st_dom = re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$\-@\.&+:/?=]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', dat)
st_ip_list = []
st_dom_list = []

if st_ip != [] and st_dom != []:
    for i in range(len(st_ip)):
        st_ip[i] = str(st_ip[i])
    st_ip = functools.reduce(operator.add, (st_ip))
    st_ip = st_ip.replace("'", "")
    st_ip = st_ip.replace("(", "")
    st_ip = st_ip.replace(")", "")
    st_ip = st_ip.replace(",", ".")
    st_ip = st_ip.replace(" ", "")
    st_ip_list = st_ip.split(' ')
    print(st_ip_list)
    st_dom = str(st_dom)
    st_dom = st_dom.replace(",", "")
    st_dom = st_dom.replace("[", "")
    st_dom = st_dom.replace("]", "")
    st_dom = st_dom.replace("'", "")
    st_dom_list = st_dom.split(' ')
    print(st_dom_list)
elif st_ip != []:
    for i in range(len(st_ip)):
        st_ip[i] = str(st_ip[i])
    st_ip = functools.reduce(operator.add, (st_ip))
    st_ip = st_ip.replace("'", "")
    st_ip = st_ip.replace("(", "")
    st_ip = st_ip.replace(")", "")
    st_ip = st_ip.replace(",", ".")
    st_ip = st_ip.replace(" ", "")
    st_ip_list = st_ip.split(' ')
    print(st_ip_list)
elif st_dom != []:
    st_dom = str(st_dom)
    st_dom = st_dom.replace(",", "")
    st_dom = st_dom.replace("[", "")
    st_dom = st_dom.replace("]", "")
    st_dom = st_dom.replace("'", "")
    st_dom_list = st_dom.split(' ')
    print(st_dom_list)
elif st_ip == [] and st_dom == []:
    print("Not Found")

if (len(st_ip_list) != 0):
    for i in st_ip_list:
        try:
            scan_url = i
            params = {'api_key': '969CF4267299A7ED4C50F26DC6F53CE35010BE007F865CA887C584F6055AD25F', 'url':i}
            headers = {'Content-Type' : 'application/x-www-form-urlencoded'}
            response = requests.post('https://public.api.malwares.com/v3/url/request', data=params, headers=headers)
            #json_response = response.json()
            #print(json_response)
            
            params = {'api_key': '969CF4267299A7ED4C50F26DC6F53CE35010BE007F865CA887C584F6055AD25F', 'url':i}
            headers = {'Content-Type' : 'application/x-www-form-urlencoded'}
            response = requests.post('https://public.api.malwares.com/v3/url/info', data=params, headers=headers)
            json_response = response.json()
            result = json.dumps(json_response, indent="\t")
            phi = result.count('phishing site')
            mal = result.count('malicious site')
            detected = phi + mal
            
            if (detected >= 1):
                print(i + ": Malicious")
                print("Detected:", detected)
            else:
                print(i + ": Clean")
        except:
            pass

if (len(st_dom_list) != 0):
    st_dom_list = set(st_dom_list)
    for i in st_dom_list:
        try:
            scan_url = i

            params = {'api_key': '969CF4267299A7ED4C50F26DC6F53CE35010BE007F865CA887C584F6055AD25F', 'url':i}
            headers = {'Content-Type' : 'application/x-www-form-urlencoded'}
            response = requests.post('https://public.api.malwares.com/v3/url/request', data=params, headers=headers)
            #json_response = response.json()
            #print(json_response)
            
            params = {'api_key': '969CF4267299A7ED4C50F26DC6F53CE35010BE007F865CA887C584F6055AD25F', 'url':i}
            headers = {'Content-Type' : 'application/x-www-form-urlencoded'}
            response = requests.post('https://public.api.malwares.com/v3/url/info', data=params, headers=headers)
            json_response = response.json()
            result = json.dumps(json_response, indent="\t")
            phi = result.count('phishing site')
            mal = result.count('malicious site')
            detected = phi + mal
            
            if (detected >= 1):
                print(i + ": Malicious")
                print("Detected:", detected)
            else:
                print(i + ": Clean")
        except:
            pass

print('\n11. Sign')

global targeApk
def getSign():
    certs = set(targeApk.get_certificates_der_v2() + [targeApk.get_certificate_der(x) for x in targeApk.get_signature_names()])
    for cert in certs:
        x509_cert = x509.Certificate.load(cert)
        Issuer = get_certificate_name_string(x509_cert.issuer.native, short=True)
        SerialNumber = hex(x509_cert.serial_number).upper().strip("0X")
        signMd5 = hashlib.md5(cert).hexdigest()
        signSha1 = hashlib.sha1(cert).hexdigest()
        signSha256 = hashlib.sha256(cert).hexdigest()
        signSha512 = hashlib.sha512(cert).hexdigest()
        return {"Issuer":Issuer,"SerialNumber":SerialNumber,"signMd5":signMd5,"signSha1":signSha1, "signSha256":signSha256, "signSha512":signSha512}

with open(sample, "rb") as f:
    rawFile = f.read()


cell_List = []
targeApk = apk.APK(rawFile,True)
apkSign  = getSign()
cell_List.append(apkSign["Issuer"])
cell_List.append(apkSign["SerialNumber"])
cell_List.append(apkSign["signMd5"])
cell_List.append(apkSign["signSha1"])
cell_List.append(apkSign["signSha256"])
cell_List.append(apkSign["signSha512"])
anal_sign = apkSign["signSha1"]
print(anal_sign)
print('\n12. API')

a, d, dx = AnalyzeAPK(sample)

api_list=[]
api_dic={}
for method in dx.find_methods():
    if method.is_external():
        continue
    m = method.get_method()
    for inst in m.get_instructions():
        try:
            if(inst.get_name().startswith('invoke')):
                out_put=inst.get_output()
                left_index=out_put.index('L')
                right_index=out_put.index('(')
                api=out_put[left_index+1:right_index]
                api=api.replace('/','.').replace(';->','.')
                #print(api)
                if(api.startswith('java') or api.startswith('android')):
                    if not "support" in api and "arch":
                        for i in Mal_API_RULE.MAL_API:
                            if(api.startswith(i)):
                                api_list.append(api)
                        
        except:
            break
    
for api_lst in api_list:
    try: api_dic[api_lst] += 1
    except: api_dic[api_lst] = 1
#print(api_dic)

for function in api_dic.keys():
    print(function,":",api_dic[function],"개")

print('\n13. Domain')

for i in st_ip_list:
    try:
        print(i)
        print('IP: ' + i)
        gi = pygeoip.GeoIP('./GeoLiteCity.dat')
        printRecord(i)
    except:
        print("Not Found")

if (len(st_ip_list) == 0):
    print("Not Found")

end = time.time()
print("수행시간: %f 초" % (end - start)+'\n')

#SCORE

try:
    Perm = apkf.get_permissions()
    score = 0 # score 초기화
    perm_score = [] # 분자에 들어가는 위협 함수 
    for s in Perm:
        Perm_list = s.replace("android.permission.","")
        try:
            MAN_PERM = PERMISSIONS_RULE_kor.DVM_PERMISSIONS['MANIFEST_PERMISSION'][Perm_list][3] 
            if len(Perm) > 15:
                score += MAN_PERM
            else:
                if MAN_PERM > 2:
                    perm_score.append(MAN_PERM) #이 부분에 들어가는건 API를 통해 교차 검증이 필요해보임
            
            
        except:
            pass
    if not len(Perm) > 15:
        score = (len(perm_score)/len(Perm)) * 100
except:
    pass

print("=====================================================================")
print('score: ', end='')
print(score)

print('status: ', end='')
url = 'https://play.google.com/store/apps/details?id='+package
html = requests.get(url)
status = html.status_code

if score > 39:
    if status == 404:
        print("악성수치 :", score)
    elif status == 200:
        chrome_options = webdriver.ChromeOptions()
        prefs = {'download.default_directory' :'D:\\apk\\', "download.prompt_for_download": False, "download.directory_upgrade": True, "safebrowsing_for_trusted_sources_enabled": False,"safebrowsing.enabled": False}
        
        chrome_options.add_experimental_option('prefs', prefs)
        chrome_options.add_argument("headless")
        chrome_options.add_argument("user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36")
        driver = webdriver.Chrome(r'D:\VSCode\chromedriver.exe',chrome_options=chrome_options)
        driver.get("https://apkpure.com/google-play-services/"+package+"/download?from=details")
        time.sleep(15)
        filename = max(['D:\\apk\\' + '\\' + f for f in os.listdir('D:\\apk\\')], key=os.path.getctime)
        os.chdir("D:\\apk")
        if '.xapk' in filename:
            os.rename(filename,filename+'.zip')
            filename = filename + '.zip'        
        
        if '.zip' in filename:
            unzip_files_dic={}
            stories_zip = zipfile.ZipFile(filename)
            unzip_storage = re.sub(".zip|.xapk","",filename)
            os.mkdir(unzip_storage)

            path = unzip_storage
            stories_zip.extractall(path)
            unzip_files = os.listdir(path)
            for apk_size in unzip_files:
                unzip_files_dic.update({apk_size:os.path.getsize(path+'\\'+apk_size )})
            Xapk_apk = max(unzip_files_dic,key=unzip_files_dic.get)
            anal_apk = path+'\\'+Xapk_apk
            apkf = APK(anal_apk)
            print ('1. App Name')
            print(apkf.get_app_name())
            with open(anal_apk, "rb") as f:
                rawFile = f.read()
            
            cell_List = []
            apkSign2  = getSign()
            cell_List.append(apkSign2["Issuer"])
            cell_List.append(apkSign2["SerialNumber"])
            cell_List.append(apkSign2["signMd5"])
            cell_List.append(apkSign2["signSha1"])
            cell_List.append(apkSign2["signSha256"])
            cell_List.append(apkSign2["signSha512"])
            download_sign = apkSign2['signSha1']
            stories_zip.close()
            shutil.rmtree(path, ignore_errors=True)
            os.remove(filename)
        else:
            print ('1. App Name')
            print(apkf.get_app_name())
            with open(filename, "rb") as f:
                rawFile = f.read()
            
            cell_List = []
            apkSign2  = getSign()
            cell_List.append(apkSign2["Issuer"])
            cell_List.append(apkSign2["SerialNumber"])
            cell_List.append(apkSign2["signMd5"])
            cell_List.append(apkSign2["signSha1"])
            cell_List.append(apkSign2["signSha256"])
            cell_List.append(apkSign2["signSha512"])
            download_sign = apkSign2['signSha1']
            os.remove(filename)
            
        if anal_sign == download_sign:
            print("인증서가 동일합니다")
        else:
            print("위험 !! 인증되지 않은 어플리케이션입니다!! ")

else:
    if status == 404:
        print("악성의심 (동적분석 필요) :", score)
    elif status == 200:
        chrome_options = webdriver.ChromeOptions()
        prefs = {'download.default_directory' :'D:\\apk\\', "download.prompt_for_download": False, "download.directory_upgrade": True, "safebrowsing_for_trusted_sources_enabled": False,"safebrowsing.enabled": False}
        
        chrome_options.add_experimental_option('prefs', prefs)
        chrome_options.add_argument("headless")
        chrome_options.add_argument("user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36")
        driver = webdriver.Chrome(r'D:\VSCode\chromedriver.exe',chrome_options=chrome_options)
        driver.get("https://apkpure.com/google-play-services/"+package+"/download?from=details")
        time.sleep(15)
        filename = max(['D:\\apk\\' + '\\' + f for f in os.listdir('D:\\apk\\')], key=os.path.getctime)
        os.chdir("D:\\apk")
        if '.xapk' in filename:
            os.rename(filename,filename+'.zip')
            filename = filename + '.zip'        
        
        if '.zip' in filename:
            unzip_files_dic={}
            stories_zip = zipfile.ZipFile(filename)
            unzip_storage = re.sub(".zip|.xapk","",filename)
            os.mkdir(unzip_storage)

            path = unzip_storage
            stories_zip.extractall(path)
            unzip_files = os.listdir(path)
            for apk_size in unzip_files:
                unzip_files_dic.update({apk_size:os.path.getsize(path+'\\'+apk_size )})
            Xapk_apk = max(unzip_files_dic,key=unzip_files_dic.get)
            anal_apk = path+'\\'+Xapk_apk
            apkf = APK(anal_apk)
            print ('1. App Name')
            print(apkf.get_app_name())
            with open(anal_apk, "rb") as f:
                rawFile = f.read()
            
            cell_List = []
            apkSign2  = getSign()
            cell_List.append(apkSign2["Issuer"])
            cell_List.append(apkSign2["SerialNumber"])
            cell_List.append(apkSign2["signMd5"])
            cell_List.append(apkSign2["signSha1"])
            cell_List.append(apkSign2["signSha256"])
            cell_List.append(apkSign2["signSha512"])
            download_sign = apkSign2['signSha1']
            stories_zip.close()
            shutil.rmtree(path, ignore_errors=True)
            os.remove(filename)
        else:
            print ('1. App Name')
            print(apkf.get_app_name())
            with open(filename, "rb") as f:
                rawFile = f.read()
            
            cell_List = []
            apkSign2  = getSign()
            cell_List.append(apkSign2["Issuer"])
            cell_List.append(apkSign2["SerialNumber"])
            cell_List.append(apkSign2["signMd5"])
            cell_List.append(apkSign2["signSha1"])
            cell_List.append(apkSign2["signSha256"])
            cell_List.append(apkSign2["signSha512"])
            download_sign = apkSign2['signSha1']
            os.remove(filename)
            
        if anal_sign == download_sign:
            print("인증서가 동일합니다")
        else:
            print("위험 !! 인증되지 않은 어플리케이션입니다!! ")
